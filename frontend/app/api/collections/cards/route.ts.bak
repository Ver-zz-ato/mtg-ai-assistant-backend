import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

/**
 * Centralized table/column constants so you can tweak names without hunting.
 * If your join table is named differently, change TABLE below.
 */
const TABLE = "collection_cards"; // <-- change if your table name differs
const COL_ID = "id";
const COL_COLLECTION_ID = "collection_id";
const COL_NAME = "name";
const COL_QTY = "qty";

/**
 * Helper: parse JSON body safely.
 */
async function readJson<T = any>(req: Request): Promise<T | null> {
  try {
    return await req.json();
  } catch {
    return null;
  }
}

function bad(message: string, status: number = 400) {
  return NextResponse.json({ ok: false, error: message }, { status });
}

export async function GET(req: Request) {
  const supabase = await createClient();
  const url = new URL(req.url);
  const collectionId = url.searchParams.get("collectionId");

  if (!collectionId) {
    return bad("Missing collectionId", 400);
  }

  // Pull rows for this collection. RLS should already scope by user.
  const { data, error } = await supabase
    .from(TABLE)
    .select("*")
    .eq(COL_COLLECTION_ID, collectionId)
    .order(COL_NAME, { ascending: true });

  if (error) {
    return bad(`Load failed: ${error.message}`, 500);
  }

  return NextResponse.json({ ok: true, items: data ?? [] });
}

export async function POST(req: Request) {
  // Add one card (name + qty) or CSV upload handler upstream
  const supabase = await createClient();
  const body = await readJson(req);
  if (!body) return bad("Invalid JSON body");

  const { collectionId, name, qty } = body as {
    collectionId?: string;
    name?: string;
    qty?: number | string;
  };

  if (!collectionId || !name) return bad("Missing collectionId or name");

  const nQty = Number(qty ?? 1);
  if (!Number.isFinite(nQty) || nQty <= 0) return bad("qty must be a positive number");

  const trimmed = String(name).trim();
  if (!trimmed) return bad("Empty name");

  // Try find existing row for (collectionId, name)
  const { data: existing, error: findErr } = await supabase
    .from(TABLE)
    .select("*")
    .eq(COL_COLLECTION_ID, collectionId)
    .eq(COL_NAME, trimmed)
    .maybeSingle();

  if (findErr) return bad(findErr.message, 500);

  if (existing) {
    // bump qty
    const newQty = Number(existing[COL_QTY] ?? 0) + nQty;
    const { error: uErr } = await supabase
      .from(TABLE)
      .update({ [COL_QTY]: newQty })
      .eq(COL_ID, existing[COL_ID]);
    if (uErr) return bad(uErr.message, 500);
    return NextResponse.json({ ok: true, id: existing[COL_ID], qty: newQty });
  } else {
    const { data: ins, error: iErr } = await supabase
      .from(TABLE)
      .insert({ [COL_COLLECTION_ID]: collectionId, [COL_NAME]: trimmed, [COL_QTY]: nQty })
      .select()
      .single();
    if (iErr) return bad(iErr.message, 500);
    return NextResponse.json({ ok: true, id: ins[COL_ID], qty: ins[COL_QTY] });
  }
}

export async function PATCH(req: Request) {
  const supabase = await createClient();
  const body = await readJson(req);
  if (!body) return bad("Invalid JSON body");

  // Accept either path: id+delta OR (collectionId+name+delta)
  const { id, collectionId, name } = body as {
    id?: string;
    collectionId?: string;
    name?: string;
  };

  // Coerce delta to a number
  const deltaRaw = (body as any).delta;
  const delta = Number(deltaRaw);
  if (!Number.isFinite(delta) || delta === 0) {
    return bad("delta must be a non-zero number");
  }

  // Fetch row to change
  let row: any | null = null;
  if (id) {
    const { data, error } = await supabase.from(TABLE).select("*").eq(COL_ID, id).maybeSingle();
    if (error) return bad(error.message, 500);
    row = data;
  } else if (collectionId && name) {
    const trimmed = String(name).trim();
    const { data, error } = await supabase
      .from(TABLE)
      .select("*")
      .eq(COL_COLLECTION_ID, collectionId)
      .eq(COL_NAME, trimmed)
      .maybeSingle();
    if (error) return bad(error.message, 500);
    row = data;
    // If no row and delta > 0, create it with delta
    if (!row && delta > 0) {
      const { data: ins, error: iErr } = await supabase
        .from(TABLE)
        .insert({ [COL_COLLECTION_ID]: collectionId, [COL_NAME]: trimmed, [COL_QTY]: delta })
        .select()
        .single();
      if (iErr) return bad(iErr.message, 500);
      return NextResponse.json({ ok: true, id: ins[COL_ID], qty: ins[COL_QTY] });
    }
  } else {
    return bad("Provide either id or (collectionId + name)");
  }

  if (!row) {
    // Nothing to update; treat as no-op
    return NextResponse.json({ ok: true, noop: true });
  }

  const current = Number(row[COL_QTY] ?? 0);
  const next = current + delta;

  if (next <= 0) {
    const { error: dErr } = await supabase.from(TABLE).delete().eq(COL_ID, row[COL_ID]);
    if (dErr) return bad(dErr.message, 500);
    return NextResponse.json({ ok: true, deleted: true });
  } else {
    const { error: uErr } = await supabase
      .from(TABLE)
      .update({ [COL_QTY]: next })
      .eq(COL_ID, row[COL_ID]);
    if (uErr) return bad(uErr.message, 500);
    return NextResponse.json({ ok: true, id: row[COL_ID], qty: next });
  }
}

export async function DELETE(req: Request) {
  const supabase = await createClient();
  const body = await readJson(req);
  if (!body) return bad("Invalid JSON body");

  const { id } = body as { id?: string };
  if (!id) return bad("Missing id");

  const { error } = await supabase.from(TABLE).delete().eq(COL_ID, id);
  if (error) return bad(error.message, 500);
  return NextResponse.json({ ok: true });
}
