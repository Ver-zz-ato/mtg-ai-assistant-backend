import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const t0 = typeof performance !== "undefined" ? performance.now() : Date.now();

  // Forward cookies to preserve Supabase session for the downstream /api/chat
  const cookie = req.headers.get("cookie") ?? "";

  // Read the incoming body once
  const raw = await req.text();

  // Try to normalize `{ content | text }` to `{ text }` before forwarding.
  // If parsing fails, we forward the original raw body (to avoid behaviour changes).
  let forwardBody: string = raw;
  try {
    const parsed = JSON.parse(raw || "{}");
    const text =
      (typeof parsed.content === "string" && parsed.content.trim().length > 0)
        ? parsed.content
        : (typeof parsed.text === "string" ? parsed.text : "");
    const { threadId, ...rest } = parsed;
    // Only normalize if we actually found a message field
    if (typeof text === "string" && text !== undefined) {
      forwardBody = JSON.stringify({ ...rest, text, threadId });
    }
  } catch {
    // ignore parse errors; keep forwardBody as raw
  }

  const res = await fetch(new URL("/api/chat", req.url), {
    method: "POST",
    headers: {
      "content-type": "application/json",
      cookie,
    },
    body: forwardBody,
    cache: "no-store",
  });

  const text = await res.text();

  const t1 = typeof performance !== "undefined" ? performance.now() : Date.now();
  const ms = Math.round((t1 as number) - (t0 as number));
  console.log(JSON.stringify({
    tag: "chat_messages_post",
    ms,
    method: "POST",
    path: "/api/chat/messages/post"
  }));

  return new Response(text, {
    status: res.status,
    headers: { "content-type": "application/json" },
  });
}
